# zprpc
中文|[English](https://github.com/65487123/zprpc/blob/master/README-EN.md)
# 功能介绍
一个高性能rpc框架，暂时只支持nacos(默认)和redis做注册中心。

# 适用场景
对调用远程服务性能要求比较高的场景。
如果服务都部署在K8S上，而又对服务间调用性能没很高要求，那么几乎没必要使用rpc框架，也没必要另外部署注册中心，基于K8S自带的功能来
实现rpc调用更合适。(访问service的clusterIp的某个端口，k8s会自己帮忙负载均衡到service对应的所有存活pod中的其中一个的某个端口上，如
果觉得功能不够，可以在这基础上定制其他功能)


# 项目整体架构
![architecture](https://github.com/65487123/zprpc/raw/master/architecture.png)
# 特点：
* 配置简单，上手容易，非常轻量，占用资源小。
* 适用场景丰富,启动过程不依赖任何组件，比如tomcat、spring(有没有这些组件，用法都一样)。
支持OSGI环境(基于OSGI的工程打成的包是bundle而不是jar,如果依赖其他框架，框架很有可能找不到bundle中的类)。
* 高性能：与市面上常见的java高性能rpc框架简单对比测试了下,目前没发现有比这个性能高的。
* 支持在不关停JVM的情况下手动关停rpc服务,关停服务后,启动时注册的所有服务实例会在注册中心中自动被移除,rpcServer监听的端口会释放(如果有正在执行的任务,会等待指定时间)。  
关停后也可以再次启动服务。
              
# 使用方法：
[nacos做注册中心](https://github.com/65487123/zprpc/blob/master/nacos.md) 

[redis做注册中心](https://github.com/65487123/zprpc/blob/master/redis.md)


## 主要实现原理：
和其他主流rpc框架类似，服务提供方把服务注册到注册中心，服务消费方到注册中心找到相应服务的所有实例，然后根据负载均衡策略找到某个实例，建立连接发起rpc调用。但是为了性能，这个rpc框架做了很多优化。  

1、不是每次rpc都会重新建立连接,实现了连接池机制,并且连接池里的连接是可以共用的,并不是取出来就少一个，然后放进去就多一个,是一个有着固定数量连接的容器(说白了就是个List),连接数量可以通过配置文件配置,默认一个。连接池里的连接也不是一次全建满,而是在客户端从注册中心中找到相应的实例后,从连接池中拿,发现连接池数量没满，就会初始化一个连接，放进连接池并返回。这其中的技术细节就涉及到多线程并发的问题，比如可见性、半初始化等。连接池中的连接会有心跳保活机制,当连接不可用了,会把这个连接从池中移除。  

2、不是每次rpc调用都会阻塞一个连接。像http1.0,每次http请求都会新建连接,请求响应结束后就关闭连接，这期间这个连接只服务这一个http请求,http1.1虽然有keepalive和Pipeling机制,但是由于有序接收响应,  会有线头阻塞问题(没收到队头请求的响应,连接就一只阻塞在那了,后续的响应只能等着)。(http2.0虽说没上述问题,并且内容以二进制编码,但是它还是http协议,http协议里有那么多没用的字段就注定性能不会很高)  
而我这个连接机制是同一时间,多个rpc请求可以共用一个连接,几乎没有任何阻塞的。  
举个例子，有A、B两个工程里面各包含了一组服务，分别部署在不同的机器上。A工程里的a方法会调用B工程里的e方法，b方法调用f方法，c方法调用g方法。
![example](https://gitee.com/zeping-lu/pngs-for-readme/raw/master/readme0.png)  
调用过程中他们都会从池中找出A工程和B工程的连接,然后通过这个连接进行RPC调用,这个过程是几乎是无序无阻塞的,a、b、c方法只要发出调用指令,然后
等着拿到rpc结果就行。(高性能rpc框架大致原理都差不多,所以代码实现细节才是决定性能差异的主要因素,比如线程间通信用锁还是park()/unpark()、请求id如何设置、方法序列化是整个方法Class序列化还是是只序列化方法名字字符串......)  
由于两个实例（ip+port）之间的所有服务通讯都是通过固定数量的连接(默认一个),充分利用了每个连接，当有大量服务时,rpc调用所
占有的cpu、内存、客户端的端口数、服务端的文件句柄数等资源会少很多。  

3、发起rpc时,不是每次都去注册中心根据serviceid找实例。只有第一次会去注册中心中找,找出实例会缓存到本地,注册中心的服务实例发生变动会
刷新本地实例缓存。  

4、客户端代理对象是单例的,只有第一次获取服务的时候会初始化,之后会保存在容器中。  

5、服务端服务对象实例也是单例的,启动服务后会保存在容器中。如果项目用到了spring,会先去spring容器种找,找不到才自己初始化。  

6、通过自定义协议解决粘包拆包,序列化用的protostuff。    
 ......
    
